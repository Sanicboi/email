/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.3
 * source: ai.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./shared";
import * as dependency_2 from "./prompts";
import * as dependency_3 from "./files";
import * as dependency_4 from "./model";
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export class UserData extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          data?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == "object") {
      if ("data" in data && data.data != undefined) {
        this.data = data.data;
      }
    }
  }
  get data() {
    return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
  }
  set data(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  static fromObject(data: { data?: string }): UserData {
    const message = new UserData({});
    if (data.data != null) {
      message.data = data.data;
    }
    return message;
  }
  toObject() {
    const data: {
      data?: string;
    } = {};
    if (this.data != null) {
      data.data = this.data;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.data.length) writer.writeString(1, this.data);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UserData {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new UserData();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.data = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): UserData {
    return UserData.deserialize(bytes);
  }
}
export class UserMessage extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          text?: string;
          resId?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == "object") {
      if ("text" in data && data.text != undefined) {
        this.text = data.text;
      }
      if ("resId" in data && data.resId != undefined) {
        this.resId = data.resId;
      }
    }
  }
  get text() {
    return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
  }
  set text(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  get resId() {
    return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
  }
  set resId(value: string) {
    pb_1.Message.setField(this, 2, value);
  }
  static fromObject(data: { text?: string; resId?: string }): UserMessage {
    const message = new UserMessage({});
    if (data.text != null) {
      message.text = data.text;
    }
    if (data.resId != null) {
      message.resId = data.resId;
    }
    return message;
  }
  toObject() {
    const data: {
      text?: string;
      resId?: string;
    } = {};
    if (this.text != null) {
      data.text = this.text;
    }
    if (this.resId != null) {
      data.resId = this.resId;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.text.length) writer.writeString(1, this.text);
    if (this.resId.length) writer.writeString(2, this.resId);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UserMessage {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new UserMessage();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.text = reader.readString();
          break;
        case 2:
          message.resId = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): UserMessage {
    return UserMessage.deserialize(bytes);
  }
}
export class ConversationData extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          resId?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == "object") {
      if ("resId" in data && data.resId != undefined) {
        this.resId = data.resId;
      }
    }
  }
  get resId() {
    return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
  }
  set resId(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  static fromObject(data: { resId?: string }): ConversationData {
    const message = new ConversationData({});
    if (data.resId != null) {
      message.resId = data.resId;
    }
    return message;
  }
  toObject() {
    const data: {
      resId?: string;
    } = {};
    if (this.resId != null) {
      data.resId = this.resId;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.resId.length) writer.writeString(1, this.resId);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConversationData {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new ConversationData();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.resId = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ConversationData {
    return ConversationData.deserialize(bytes);
  }
}
export class AIMessage extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          text?: string;
          id?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == "object") {
      if ("text" in data && data.text != undefined) {
        this.text = data.text;
      }
      if ("id" in data && data.id != undefined) {
        this.id = data.id;
      }
    }
  }
  get text() {
    return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
  }
  set text(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  get id() {
    return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
  }
  set id(value: string) {
    pb_1.Message.setField(this, 2, value);
  }
  static fromObject(data: { text?: string; id?: string }): AIMessage {
    const message = new AIMessage({});
    if (data.text != null) {
      message.text = data.text;
    }
    if (data.id != null) {
      message.id = data.id;
    }
    return message;
  }
  toObject() {
    const data: {
      text?: string;
      id?: string;
    } = {};
    if (this.text != null) {
      data.text = this.text;
    }
    if (this.id != null) {
      data.id = this.id;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.text.length) writer.writeString(1, this.text);
    if (this.id.length) writer.writeString(2, this.id);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AIMessage {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new AIMessage();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.text = reader.readString();
          break;
        case 2:
          message.id = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): AIMessage {
    return AIMessage.deserialize(bytes);
  }
}
export class ConversationAnalysis extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          enthusiasm?: number;
          rating?: number;
          comment?: string;
          isDelayed?: boolean;
          delayDate?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == "object") {
      if ("enthusiasm" in data && data.enthusiasm != undefined) {
        this.enthusiasm = data.enthusiasm;
      }
      if ("rating" in data && data.rating != undefined) {
        this.rating = data.rating;
      }
      if ("comment" in data && data.comment != undefined) {
        this.comment = data.comment;
      }
      if ("isDelayed" in data && data.isDelayed != undefined) {
        this.isDelayed = data.isDelayed;
      }
      if ("delayDate" in data && data.delayDate != undefined) {
        this.delayDate = data.delayDate;
      }
    }
  }
  get enthusiasm() {
    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
  }
  set enthusiasm(value: number) {
    pb_1.Message.setField(this, 1, value);
  }
  get rating() {
    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
  }
  set rating(value: number) {
    pb_1.Message.setField(this, 2, value);
  }
  get comment() {
    return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
  }
  set comment(value: string) {
    pb_1.Message.setField(this, 3, value);
  }
  get isDelayed() {
    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
  }
  set isDelayed(value: boolean) {
    pb_1.Message.setField(this, 4, value);
  }
  get delayDate() {
    return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
  }
  set delayDate(value: string) {
    pb_1.Message.setField(this, 5, value);
  }
  static fromObject(data: {
    enthusiasm?: number;
    rating?: number;
    comment?: string;
    isDelayed?: boolean;
    delayDate?: string;
  }): ConversationAnalysis {
    const message = new ConversationAnalysis({});
    if (data.enthusiasm != null) {
      message.enthusiasm = data.enthusiasm;
    }
    if (data.rating != null) {
      message.rating = data.rating;
    }
    if (data.comment != null) {
      message.comment = data.comment;
    }
    if (data.isDelayed != null) {
      message.isDelayed = data.isDelayed;
    }
    if (data.delayDate != null) {
      message.delayDate = data.delayDate;
    }
    return message;
  }
  toObject() {
    const data: {
      enthusiasm?: number;
      rating?: number;
      comment?: string;
      isDelayed?: boolean;
      delayDate?: string;
    } = {};
    if (this.enthusiasm != null) {
      data.enthusiasm = this.enthusiasm;
    }
    if (this.rating != null) {
      data.rating = this.rating;
    }
    if (this.comment != null) {
      data.comment = this.comment;
    }
    if (this.isDelayed != null) {
      data.isDelayed = this.isDelayed;
    }
    if (this.delayDate != null) {
      data.delayDate = this.delayDate;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.enthusiasm != 0) writer.writeInt32(1, this.enthusiasm);
    if (this.rating != 0) writer.writeInt32(2, this.rating);
    if (this.comment.length) writer.writeString(3, this.comment);
    if (this.isDelayed != false) writer.writeBool(4, this.isDelayed);
    if (this.delayDate.length) writer.writeString(5, this.delayDate);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(
    bytes: Uint8Array | pb_1.BinaryReader,
  ): ConversationAnalysis {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new ConversationAnalysis();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.enthusiasm = reader.readInt32();
          break;
        case 2:
          message.rating = reader.readInt32();
          break;
        case 3:
          message.comment = reader.readString();
          break;
        case 4:
          message.isDelayed = reader.readBool();
          break;
        case 5:
          message.delayDate = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ConversationAnalysis {
    return ConversationAnalysis.deserialize(bytes);
  }
}
export class MessageEvaluation extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          rating?: number;
          comment?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == "object") {
      if ("rating" in data && data.rating != undefined) {
        this.rating = data.rating;
      }
      if ("comment" in data && data.comment != undefined) {
        this.comment = data.comment;
      }
    }
  }
  get rating() {
    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
  }
  set rating(value: number) {
    pb_1.Message.setField(this, 1, value);
  }
  get comment() {
    return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
  }
  set comment(value: string) {
    pb_1.Message.setField(this, 2, value);
  }
  static fromObject(data: {
    rating?: number;
    comment?: string;
  }): MessageEvaluation {
    const message = new MessageEvaluation({});
    if (data.rating != null) {
      message.rating = data.rating;
    }
    if (data.comment != null) {
      message.comment = data.comment;
    }
    return message;
  }
  toObject() {
    const data: {
      rating?: number;
      comment?: string;
    } = {};
    if (this.rating != null) {
      data.rating = this.rating;
    }
    if (this.comment != null) {
      data.comment = this.comment;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.rating != 0) writer.writeInt32(1, this.rating);
    if (this.comment.length) writer.writeString(2, this.comment);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MessageEvaluation {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new MessageEvaluation();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.rating = reader.readInt32();
          break;
        case 2:
          message.comment = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): MessageEvaluation {
    return MessageEvaluation.deserialize(bytes);
  }
}
interface GrpcUnaryServiceInterface<P, R> {
  (
    message: P,
    metadata: grpc_1.Metadata,
    options: grpc_1.CallOptions,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientUnaryCall;
  (
    message: P,
    metadata: grpc_1.Metadata,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientUnaryCall;
  (
    message: P,
    options: grpc_1.CallOptions,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientUnaryCall;
  (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
}
interface GrpcStreamServiceInterface<P, R> {
  (
    message: P,
    metadata: grpc_1.Metadata,
    options?: grpc_1.CallOptions,
  ): grpc_1.ClientReadableStream<R>;
  (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
}
interface GrpWritableServiceInterface<P, R> {
  (
    metadata: grpc_1.Metadata,
    options: grpc_1.CallOptions,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientWritableStream<P>;
  (
    metadata: grpc_1.Metadata,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientWritableStream<P>;
  (
    options: grpc_1.CallOptions,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientWritableStream<P>;
  (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
}
interface GrpcChunkServiceInterface<P, R> {
  (
    metadata: grpc_1.Metadata,
    options?: grpc_1.CallOptions,
  ): grpc_1.ClientDuplexStream<P, R>;
  (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
}
interface GrpcPromiseServiceInterface<P, R> {
  (
    message: P,
    metadata: grpc_1.Metadata,
    options?: grpc_1.CallOptions,
  ): Promise<R>;
  (message: P, options?: grpc_1.CallOptions): Promise<R>;
}
export abstract class UnimplementedAIService {
  static definition = {
    getPrompt: {
      path: "/AI/getPrompt",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: dependency_2.Agent) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        dependency_2.Agent.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: dependency_2.Prompt) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        dependency_2.Prompt.deserialize(new Uint8Array(bytes)),
    },
    setPrompt: {
      path: "/AI/setPrompt",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: dependency_2.Prompt) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        dependency_2.Prompt.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: dependency_1.Empty) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        dependency_1.Empty.deserialize(new Uint8Array(bytes)),
    },
    getFiles: {
      path: "/AI/getFiles",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: dependency_1.Empty) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        dependency_1.Empty.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: dependency_3.FilesList) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        dependency_3.FilesList.deserialize(new Uint8Array(bytes)),
    },
    addFile: {
      path: "/AI/addFile",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: dependency_3.FileData) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        dependency_3.FileData.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: dependency_3.FileName) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        dependency_3.FileName.deserialize(new Uint8Array(bytes)),
    },
    deleteFile: {
      path: "/AI/deleteFile",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: dependency_3.FileName) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        dependency_3.FileName.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: dependency_1.Empty) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        dependency_1.Empty.deserialize(new Uint8Array(bytes)),
    },
    getModel: {
      path: "/AI/getModel",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: dependency_2.Agent) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        dependency_2.Agent.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: dependency_4.ModelData) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        dependency_4.ModelData.deserialize(new Uint8Array(bytes)),
    },
    setModel: {
      path: "/AI/setModel",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: dependency_4.ModelData) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        dependency_4.ModelData.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: dependency_1.Empty) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        dependency_1.Empty.deserialize(new Uint8Array(bytes)),
    },
    write: {
      path: "/AI/write",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: UserData) => Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        UserData.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: AIMessage) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        AIMessage.deserialize(new Uint8Array(bytes)),
    },
    respond: {
      path: "/AI/respond",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: UserMessage) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        UserMessage.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: AIMessage) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        AIMessage.deserialize(new Uint8Array(bytes)),
    },
    heat: {
      path: "/AI/heat",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: ConversationData) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        ConversationData.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: AIMessage) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        AIMessage.deserialize(new Uint8Array(bytes)),
    },
    analyze: {
      path: "/AI/analyze",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: UserMessage) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        UserMessage.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: ConversationAnalysis) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        ConversationAnalysis.deserialize(new Uint8Array(bytes)),
    },
    evaluate: {
      path: "/AI/evaluate",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: ConversationData) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        ConversationData.deserialize(new Uint8Array(bytes)),
      responseSerialize: (message: MessageEvaluation) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        MessageEvaluation.deserialize(new Uint8Array(bytes)),
    },
  };
  [method: string]: grpc_1.UntypedHandleCall;
  abstract getPrompt(
    call: grpc_1.ServerUnaryCall<dependency_2.Agent, dependency_2.Prompt>,
    callback: grpc_1.sendUnaryData<dependency_2.Prompt>,
  ): void;
  abstract setPrompt(
    call: grpc_1.ServerUnaryCall<dependency_2.Prompt, dependency_1.Empty>,
    callback: grpc_1.sendUnaryData<dependency_1.Empty>,
  ): void;
  abstract getFiles(
    call: grpc_1.ServerUnaryCall<dependency_1.Empty, dependency_3.FilesList>,
    callback: grpc_1.sendUnaryData<dependency_3.FilesList>,
  ): void;
  abstract addFile(
    call: grpc_1.ServerUnaryCall<dependency_3.FileData, dependency_3.FileName>,
    callback: grpc_1.sendUnaryData<dependency_3.FileName>,
  ): void;
  abstract deleteFile(
    call: grpc_1.ServerUnaryCall<dependency_3.FileName, dependency_1.Empty>,
    callback: grpc_1.sendUnaryData<dependency_1.Empty>,
  ): void;
  abstract getModel(
    call: grpc_1.ServerUnaryCall<dependency_2.Agent, dependency_4.ModelData>,
    callback: grpc_1.sendUnaryData<dependency_4.ModelData>,
  ): void;
  abstract setModel(
    call: grpc_1.ServerUnaryCall<dependency_4.ModelData, dependency_1.Empty>,
    callback: grpc_1.sendUnaryData<dependency_1.Empty>,
  ): void;
  abstract write(
    call: grpc_1.ServerUnaryCall<UserData, AIMessage>,
    callback: grpc_1.sendUnaryData<AIMessage>,
  ): void;
  abstract respond(
    call: grpc_1.ServerUnaryCall<UserMessage, AIMessage>,
    callback: grpc_1.sendUnaryData<AIMessage>,
  ): void;
  abstract heat(
    call: grpc_1.ServerUnaryCall<ConversationData, AIMessage>,
    callback: grpc_1.sendUnaryData<AIMessage>,
  ): void;
  abstract analyze(
    call: grpc_1.ServerUnaryCall<UserMessage, ConversationAnalysis>,
    callback: grpc_1.sendUnaryData<ConversationAnalysis>,
  ): void;
  abstract evaluate(
    call: grpc_1.ServerUnaryCall<ConversationData, MessageEvaluation>,
    callback: grpc_1.sendUnaryData<MessageEvaluation>,
  ): void;
}
export class AIClient extends grpc_1.makeGenericClientConstructor(
  UnimplementedAIService.definition,
  "AI",
  {},
) {
  constructor(
    address: string,
    credentials: grpc_1.ChannelCredentials,
    options?: Partial<grpc_1.ChannelOptions>,
  ) {
    super(address, credentials, options);
  }
  getPrompt: GrpcPromiseServiceInterface<
    dependency_2.Agent,
    dependency_2.Prompt
  > = (
    message: dependency_2.Agent,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<dependency_2.Prompt> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.getPrompt(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: dependency_2.Prompt) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  setPrompt: GrpcPromiseServiceInterface<
    dependency_2.Prompt,
    dependency_1.Empty
  > = (
    message: dependency_2.Prompt,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<dependency_1.Empty> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.setPrompt(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: dependency_1.Empty) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  getFiles: GrpcPromiseServiceInterface<
    dependency_1.Empty,
    dependency_3.FilesList
  > = (
    message: dependency_1.Empty,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<dependency_3.FilesList> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.getFiles(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: dependency_3.FilesList) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  addFile: GrpcPromiseServiceInterface<
    dependency_3.FileData,
    dependency_3.FileName
  > = (
    message: dependency_3.FileData,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<dependency_3.FileName> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.addFile(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: dependency_3.FileName) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  deleteFile: GrpcPromiseServiceInterface<
    dependency_3.FileName,
    dependency_1.Empty
  > = (
    message: dependency_3.FileName,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<dependency_1.Empty> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.deleteFile(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: dependency_1.Empty) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  getModel: GrpcPromiseServiceInterface<
    dependency_2.Agent,
    dependency_4.ModelData
  > = (
    message: dependency_2.Agent,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<dependency_4.ModelData> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.getModel(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: dependency_4.ModelData) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  setModel: GrpcPromiseServiceInterface<
    dependency_4.ModelData,
    dependency_1.Empty
  > = (
    message: dependency_4.ModelData,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<dependency_1.Empty> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.setModel(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: dependency_1.Empty) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  write: GrpcPromiseServiceInterface<UserData, AIMessage> = (
    message: UserData,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<AIMessage> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.write(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: AIMessage) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  respond: GrpcPromiseServiceInterface<UserMessage, AIMessage> = (
    message: UserMessage,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<AIMessage> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.respond(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: AIMessage) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  heat: GrpcPromiseServiceInterface<ConversationData, AIMessage> = (
    message: ConversationData,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<AIMessage> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.heat(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: AIMessage) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  analyze: GrpcPromiseServiceInterface<UserMessage, ConversationAnalysis> = (
    message: UserMessage,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<ConversationAnalysis> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.analyze(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: ConversationAnalysis) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
  evaluate: GrpcPromiseServiceInterface<ConversationData, MessageEvaluation> = (
    message: ConversationData,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<MessageEvaluation> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.evaluate(
        message,
        metadata,
        options,
        (error: grpc_1.ServiceError, response: MessageEvaluation) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
}
