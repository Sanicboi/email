/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.3
 * source: files.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export class FileName extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          name?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == "object") {
      if ("name" in data && data.name != undefined) {
        this.name = data.name;
      }
    }
  }
  get name() {
    return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
  }
  set name(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  static fromObject(data: { name?: string }): FileName {
    const message = new FileName({});
    if (data.name != null) {
      message.name = data.name;
    }
    return message;
  }
  toObject() {
    const data: {
      name?: string;
    } = {};
    if (this.name != null) {
      data.name = this.name;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.name.length) writer.writeString(1, this.name);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileName {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new FileName();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.name = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): FileName {
    return FileName.deserialize(bytes);
  }
}
export class FilesList extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          names?: FileName[];
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [1],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == "object") {
      if ("names" in data && data.names != undefined) {
        this.names = data.names;
      }
    }
  }
  get names() {
    return pb_1.Message.getRepeatedWrapperField(
      this,
      FileName,
      1,
    ) as FileName[];
  }
  set names(value: FileName[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  static fromObject(data: {
    names?: ReturnType<typeof FileName.prototype.toObject>[];
  }): FilesList {
    const message = new FilesList({});
    if (data.names != null) {
      message.names = data.names.map((item) => FileName.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      names?: ReturnType<typeof FileName.prototype.toObject>[];
    } = {};
    if (this.names != null) {
      data.names = this.names.map((item: FileName) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.names.length)
      writer.writeRepeatedMessage(1, this.names, (item: FileName) =>
        item.serialize(writer),
      );
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FilesList {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new FilesList();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.names, () =>
            pb_1.Message.addToRepeatedWrapperField(
              message,
              1,
              FileName.deserialize(reader),
              FileName,
            ),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): FilesList {
    return FilesList.deserialize(bytes);
  }
}
export class FileData extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          content?: Uint8Array;
          extension?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == "object") {
      if ("content" in data && data.content != undefined) {
        this.content = data.content;
      }
      if ("extension" in data && data.extension != undefined) {
        this.extension = data.extension;
      }
    }
  }
  get content() {
    return pb_1.Message.getFieldWithDefault(
      this,
      1,
      new Uint8Array(0),
    ) as Uint8Array;
  }
  set content(value: Uint8Array) {
    pb_1.Message.setField(this, 1, value);
  }
  get extension() {
    return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
  }
  set extension(value: string) {
    pb_1.Message.setField(this, 2, value);
  }
  static fromObject(data: {
    content?: Uint8Array;
    extension?: string;
  }): FileData {
    const message = new FileData({});
    if (data.content != null) {
      message.content = data.content;
    }
    if (data.extension != null) {
      message.extension = data.extension;
    }
    return message;
  }
  toObject() {
    const data: {
      content?: Uint8Array;
      extension?: string;
    } = {};
    if (this.content != null) {
      data.content = this.content;
    }
    if (this.extension != null) {
      data.extension = this.extension;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.content.length) writer.writeBytes(1, this.content);
    if (this.extension.length) writer.writeString(2, this.extension);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileData {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new FileData();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.content = reader.readBytes();
          break;
        case 2:
          message.extension = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): FileData {
    return FileData.deserialize(bytes);
  }
}
